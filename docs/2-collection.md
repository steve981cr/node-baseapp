# Add an Articles Collection to the base app.
* These are the instructions that were used to add an articles collection to this app. 
* You can recreate it by following these instructions.
* We will persist the data with a SQLite database. You can switch it out for MySQL or Postgres.
* We will use the Sequelize ORM package.
* We will use express-validator to validate/sanitize form data.

---
## Installation and configuration
```npm install sequelize sqlite3 express-validator```  
* Sequelize has a CLI tool called sequelize-cli. You can either install it as a local development dependency, install it globally, or not install it at all and run it with npx.  
To install it globally: `npm i -g sequelize-cli`  
* Generate the file structure: `sequelize init`  
This creates folders/files for sequelize config, models, migrations, and seeders.
* Modify the config/config.json file for SQLite. See file for the configuration.

---
## 1) Generate a model and add table to the DB
* The articles collection will have fields for title, content, published, and autogenerated fields for id, createAt, and updatedAt.
* 1a) Run the sequelize-cli command to generate a model and migration file:  
```
sequelize model:generate --name Article --attributes title:string,content:text,published:boolean
```
* 1b) Make modifications to the migration file if necessary. For example, you could set a default value to true to the published field. 
* 1c) Run the migration file to add the table to the database:
```
sequelize migrate:db
```
* 1d) Optionally confirm the table was added to the (SQLite) DB schema
  * Open the SQLite shell: `sqlite3 database.sqlite3`
  * View the DB Schema: `.schema`
  * Exit the shell: `Ctrl+D`

### 1.2) Modify the Model files if necessary.
* We'll leave the model as is, but you could do something like set the default value of published to true.
``` javascript
// models/article.js
...
Article.init({
  title: DataTypes.STRING,
  content: DataTypes.STRING,
  published: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
  }
}
...
```

### 1.3) Generate a seed file to add records to the DB:
* 1.3a) Generate the seeder file.  
`sequelize seed:generate --name seed-article`
* 1.3b) Add articles to the seeder file. See seeders/*YYYYMMDDHHMMSS*-seed-article.js
* 1.3c) Run the seeder file:
`sequelize db:seed:all`
* 1.3d) Optionally confirm the seed data was added to the (SQLite) DB.
  * Open the SQLite shell: `sqlite3 database.sqlite3`
  * Query the DB: `SELECT * FROM Articles;`
  * Exit the shell: `Ctrl+D`

---
## 2) Routes
* Populate the router file for the collection. It will hold the routes, controller, and form validations.
* Add the collection's router as middleware to the app.
### 2.1) Add articles router middleware to app.js
* Import the routes/articles.js router module.
* Add it as middleware to the app.
#### **`app.js`**
``` js
const articlesRouter = require('./routes/articles');
...
app.use('/articles', articlesRouter);
```
* Now any HTTP request to /articles will be handled by the articlesRouter module.

### 2.2) Add routes
* Add the routes for the Articles collection.
* At the top import Express and instantiate an express router. 
* The controller functions will also be placed in this file. For that we will need to import:
  * The Article model. 
  * The http-errors package to format errors for http responses. 
  * Express-validator to validate and/or sanitize form data.
* Add a router method for each route.  
  `router.METHOD(path, callback [, callback ...])`
* The router.get() method serves GET requests for HTML pages including:
  * List page of all articles, or a filtered list of articles.
  * Detail page showing a specific article.
  * Form pages to Create, Update, and Delete an article.
* the router.post() method handles POST requests with form data including:
  * forms data to Create, Update, and Delete an article.
  * HTML forms can only send POST or GET requests.
* Add placeholder controller functions for the router callbacks.
* Add a placeholder for form validation.

#### **`routes/articles.js`**
``` JavaScript
const express = require('express');
const router = express.Router();
const { Article } = require('../models');
const createError = require('http-errors');
const { body, validationResult } = require('express-validator');

// Articles routes
router.get('/', list);
router.get('/create', createForm);
router.post('/create', validateForm(), create);
router.get('/:id', detail);
router.get('/:id/update', updateForm);
router.post('/:id/update', validateForm(), update);
router.get('/:id/delete', deleteForm);
router.post('/:id/delete', destroy);

// Controller functions placeholders
function list(req, res, next) {}
function createForm(req, res, next) {}
function create(req, res, next) {}
function detail(req, res, next) {}
function updateForm(req, res, next) {}
function update(req, res, next) {}
function deleteForm(req, res, next) {}
function destroy(req, res, next) {}

// Validation placeholder
function validateForm() { return []; }
```

---
## 4) Views setup
* Add a view folder and files for the articles.
```
mkdir views/articles
touch views/articles/list.ejs
touch views/articles/details.ejs
touch views/articles/create.ejs
touch views/articles/update.ejs
touch views/articles/delete.ejs
```
---
## 3&4.1) List Controller Function and View
### Route
* GET Requests to /articles are handled by the controller list function.
``` JavaScript
router.get('/', list);
```
### Controller List Function
``` JavaScript
// GET /articles
async function list(req, res, next) {
  try {
    const articles = await Article.findAll({ 
      // where: {published: true},
      attributes: ['id', 'title', 'published', 'createdAt'],
      order: [['createdAt', 'DESC']]
    });    
    res.render('articles/list', { title: 'Articles', articles: articles });
  } catch (err) {
    console.log('Error querying articles', JSON.stringify(err))
    return next(err);
  }
};
```
* Wrap the query in a try/catch block. That way if there is an error the catch clause will handle it. 
* Query the database using the Sequelize findAll() function chained to the Article model.
  * All database queries are asynchronous, so add await so the function will wait for the results before going to the next statement.
  * Optionally include a where clause to only find published articles.
  * The attributes property specifies which attributes to pull. For the list page we are excluding the content attribute.
  * Order the articles by createdAt date in descending order.
  * Sequelize ORM will query the database and convert the results into an array of article objects.
* Render the list view template, passing in a variables object containing the title and articles array from the database.
* If there is an error catch it, then log it to the console.
  * Call the next() method passing in the error object as the argument. Express will then pass it to the error handling function at the bottom of the app.js file and display the error HTML page.

### List View
* See the views/articles/list.ejs file for the HTML and EJS code.
* At the top is a button link to the Create article form.
* Iterate over the articles array displaying each article title with a link to the article detail page.
* You can display the results as an unordered list, an ordered list, a description list, a table, or some other format. 
* The example uses an Unordered list, but has commented out code for a description list and a table. 

---
## 3&4.2) Detail Route, Controller Function, View
### Route
* GET Requests to /articles/:id are handled by the controller details function.
* :id is a route parameter. It can be accessed in the controller from the request params property `req.params.id`.
``` JavaScript
router.get('/:id', detail);
```
### Controller Details Function

``` JavaScript
async function detail(req, res, next) { 
  try {
    const article = await Article.findByPk(req.params.id);
    if (!article) {
      return next(createError(404));
    }
    res.render('articles/detail', { title: 'Article', 
      article: article });    
  } catch (err) {
    return next(err);    
  }
};
```
* The details controller function pulls the article from the database and renders the details template.
* Call the Sequelize findByPk() method passing in the article id, which is the primary key.
* Sequelize methods are asynchronous so use the await keyword to wait for the result before moving on to the next statement.
* If there is no article found then call the next() middleware function, passing in a 404 Not Found error. If there is an argument in next() Express treats it as an error object and passes it to the error handler middleware.
* If an article is found, render the articles/details template file. Pass it the article object.
* The details function is in a try/catch block. If there is an error, other than the 404, the catch block will catch it and pass it to next(err).

### List View
* See the views/articles/details.ejs file for the HTML and EJS code.
* At the top is a button link to the Create article form.
* Iterate over the articles array displaying each article title with a link to the article detail page.
* You can display the results as an unordered list, an ordered list, a description list, a table, or some other format. 
* The example uses an Unordered list, but has commented out code for a description list and a table. 

---
## 3&4.3) Create Routes, Controller Functions, Form View
## GET Request: Display Form
* User clicks the link to the Create Article form (a GET request):
### Route: 
``` JavaScript
router.get('/create', createForm);
```
### Controller Callback Function:
``` JavaScript
// GET /articles/create
function createView(req, res, next) {
  res.render('articles/create', { title: 'Create Article' });
};
```
* User fills out form and hits the submit button (a POST request with form data):
## POST Request: Process Form
### Route: 
``` JavaScript
router.post('/create', validateForm(), create);
```
### Controller Callback Function:
``` JavaScript
// POST /articles/create
async function create(req, res, next) {
  // Check request's validation result. Wrap errors in an object.
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.render('articles/create', { title: 'Create Article', 
      article: req.body, errors: errors.array() });
  }
  try {
    const article = await Article.create(req.body);
    res.redirect(`/articles/${article.id}`);    
  } catch (err) {
    return next(err);    
  }
};
```
* The first few statements handle form submissions that fail the validation middleware.
  * The validation errors are returned as an object. Assign it to an errors variable.
  * Re-render the create form. Pass back in the title, the values submitted in the form, and the errors object.
* If the validations pass then save the form data to the database.
  * Chain the Sequelize create() method to the Article model. 
  * Sequelize methods that interact with the database are asynchronous. 
    * As such the whole controller function needs to be prefaced with async.
    * And this method needs to be prefaced with await so that the transaction completes before moving to the next statement.
* After the article record is created in the database, redirect to the article detail page.

---
## 3&4.4) Update Routes, Controller Functions, Form View
## GET Request: Display Form
* The article detail page has an Edit button with a link to the Update form.
``` html
<a href="/articles/<%= article.id %>/update">Edit</a>
```
### Route: 
``` JavaScript
router.get('/:id/update', updateForm);
```
### Controller Callback Function:
``` js
// GET /articles/:id/update
async function updateForm(req, res, next) { 
  try {
    const article = await Article.findByPk(req.params.id);
    if (!article) { eturn next(createError(404)) }
    res.render('articles/update', { title: 'Update Article', 
      article: article });    
  } catch (err) {
    return next(err);    
  }
}
```
* User fills out form and hits the submit button (a POST request with form data):

## POST Request: Process Form
### Route: 
``` JavaScript
router.post('/:id/update', validateForm(), update);
```
* ValidateForm() is a middleware function we will populate later.

### Controller Callback Function:
``` js
// POST /articles/:id/update
async function update(req, res, next) {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.render('articles/update', { title: 'Update Article', 
      article: req.body, errors: errors.array() });
  }
  try {
    const id = parseInt(req.params.id);
    const article = await Article.findByPk(id);    
    const { title, content, published } = req.body;
    await article.update({ title, content, published });
    req.flash('info', 'Article has been updated.');
    res.redirect(`/articles/${id}`); 
  } catch (err) {
    return next(err);    
  }
}
```
* The first statement are to handle validation errors.
  * If the validation middleware returns any errors then re-render the update form.
  * Pass back the title, the form data that was submitted, and an array of errors.
* If no errors then get the article id from the route and pull the article from the DB.
* Get the form fields from the request body and use them to update the record in the DB.
* Redirect to the article detail page.

---
## 3&4.5) Delete Routes, Controller Functions, Form View
## GET Request: Display Form
* The article update page has a Delete button with a link to the Delete form.
``` html
<a href="/articles/<%= article.id %>/delete">Delete</a>
```
### Route: 
``` JavaScript
router.get('/:id/delete', deleteForm);
```
### Controller Callback Function:
``` js
// GET /articles/:id/delete
async function deleteForm(req, res, next) {
  try {
    const article = await Article.findByPk(req.params.id);
    if (!article) { return next(createError(404)) }
    res.render('articles/delete', { title: 'Delete Article', 
      article: article });    
  } catch (err) {
    return next(err);    
  }
}
```
* User confirms they really do want to delete this article and clicks Confirm delete.
* This is actually a form that submits a POST request.
```

```

## POST Request: Process Form
### Route: 
``` JavaScript
router.post('/:id/delete', delete);
```
### Controller Callback Function:
``` js
// POST articles/:id/delete
async function destroy(req, res, next) {
  try {
    const id = parseInt(req.params.id);
    const article = await Article.findByPk(id);    
    await article.destroy();
    req.flash('info', 'Article has been deleted.');
    res.redirect('/articles');
  } catch (err) {
    return next(err);    
  }
}
```

---
## Validation and Sanitation
* Ref: [express-validator.github.io/docs]('https://express-validator.github.io/docs/')
* We installed and imported the express-validator package.
* Fill out the placeholder validator array. 
* We put it inside a function and called the function as middleware in the route. By placing the validator array in a function, we can put it after the router functions. JavaScript functions are hoisted to the top of the module, while variables are not.
``` js
const { body, validationResult } = require('express-validator');
...
// Routes with validation middleware
router.post('/create', auth.isLoggedIn, validateForm(), create);
router.post('/:id/update', validateForm(), update);
...
function validateForm() {
  return [
    body('title').trim().not().isEmpty()
    .withMessage('Title is required.').isLength({ max: 200 })
    .withMessage('Title should not exceed 200 characters.')
    .matches(/^[\w'",.!?\- ]+$/)
    .withMessage(`Title should only contain letters, numbers, spaces, and '",.!?- characters.`),
    body('content').trim().escape().isLength({ min: 3 })
    .withMessage('Article content must be at least 3 characters.')
    .isLength({ max: 5000 })
    .withMessage('Article content should not exceed 5000 characters.'),
  ]
}
```
* Each item in the array is a validator for a form field.
* You can chain multiple validator methods on the same field.
* Validation means checking that requirements are met such as minimum length.
* Sanitization involves modifying the data before saving it such as trimming leading and trailing spaces, or downcasing email addresses.